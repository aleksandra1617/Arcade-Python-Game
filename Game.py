import random
import pygame
import time

from Snake import Snake
import GUI

pygame.init()

width = 1080
height = 720

run = True

# Window
window = pygame.display.set_mode([width, height])
pygame.display.set_caption("Snake")

# The clock is needed for time keeping
clock = pygame.time.Clock()


# Get key input (QUIT, KEY DOWN, LEFT MOUSE CLICK, etc)
# Ideally the quit event and other window events will not be checked in the same place as
# player controls but because the alternative method for key checking is not as reliable
# I have chosen to keep this method and add one extra condition (player.lives > 0)
# Eventually all entities would be contained in a data structure which will be passed instead of player object.
def get_key_entered(player):
    global run
    for event in pygame.event.get():

        if event.type == pygame.QUIT:
            run = False
            pygame.quit()
            quit()

        elif (event.type == pygame.KEYDOWN) and (player.lives > 0):
            player.change_move_direction(event.key)


# Generates a random position for a given object.
# @params:
#   *app_width - width of the object to spawn.
#   *app_height - height of the object to spawn.
#   *game_view - dimensions and coordinates of the rectangle on which the game is rendered.
def gen_random_spawn_location(object_width, object_height, spawn_area_scale):

    # The random X and Y are generated by taking into account the spawn area.
    rand_x = random.randint(spawn_area_scale[0], spawn_area_scale[2] - object_height)
    rand_y = random.randint(spawn_area_scale[1], spawn_area_scale[3] - object_width)

    return rand_x, rand_y


def main():
    start_timer = 0
    invincibility_time = 2

    view_width = 1000
    view_height = 600

    # Calculate game view rectangle starting position
    start_x = (width - view_width) / 2
    start_y = (height - view_height) / 2

    spawn_area_scale = (start_x, start_y, view_width, view_height)

    score = 0
    live_taken = False

    # Construct a snake
    snake = Snake(400, 400, 3, 3, 15, (0, 0, 0))

    # Apple scale
    app_width = 10
    app_height = 10

    # Randomise apple position
    rand_x, rand_y = gen_random_spawn_location(app_width, app_height, spawn_area_scale)

    # Game loop
    while run:
        curr_time = time.time()

        # Draw background, needs to happen every frame
        window.fill((255, 255, 255))

        spawn_area = pygame.draw.rect(window, (98, 244, 66), spawn_area_scale)
        # (Simply Visual) Spawn Area Border
        pygame.draw.rect(window, (3, 132, 36), spawn_area_scale, 4)

        # Draw apple
        apple = pygame.draw.rect(window, (255, 0, 0), (rand_x, rand_y, app_width, app_height))

        # Player controls and other events
        get_key_entered(snake)

        if snake.lives > 0:
            snake.draw_snake(window)
            snake.update_position()

            # If the apple was eaten
            if snake.eat(apple):
                # Spawn a new apple
                rand_x, rand_y = gen_random_spawn_location(app_width, app_height, spawn_area_scale)

                # Update score
                score += 5

            print ("Snake size: ", snake.segments.size)

            snake_x = snake.segments.head.rect.x
            snake_y = snake.segments.head.rect.y

            # The top left and top right corners of the snake head.
            # Those exact points create the exact boundary needed and at the same time save computation.
            s_tl = (snake_x, snake_y)
            s_tr = (snake_x+snake.segment_size, snake_y+snake.segment_size)

            not_collide_top_left = not spawn_area.collidepoint(s_tl)
            not_collide_top_right = not spawn_area.collidepoint(s_tr)

            if not_collide_top_left and not_collide_top_right and not live_taken:
                start_timer = curr_time
                snake.lives -= 1
                live_taken = True

            # Can loose a life again
            if round(curr_time - start_timer, 0) == invincibility_time:
                live_taken = False

        else:   # GAME OVER

            pygame.draw.rect(window, (155, 50, 50), (start_x-2, start_y-2, view_width+4, view_height+4))
            GUI.display_text(window, "GAME OVER! ", 100, (0, 0, 0), [310, 300])

        # GUI
        GUI.display_text(window, "Score: " + str(score), 50, (0, 0, 0), [40, 10])
        GUI.display_text(window, "Lives: " + str(snake.lives), 50, (0, 0, 0), [910, 10])

        # Limit frames to 60
        clock.tick(60)

        # Displays the buffered data
        pygame.display.update()


main()
